from __future__ import annotations
import typing as t
import typing_extensions as tx
from types import ModuleType
import pathlib
import dataclasses
from functools import partial

from prestring.output import output
from monogusa.dependencies import scan_module, Scanned
from monogusa.langhelpers import reify

from ._codeobject import Module
from ._fnspec import fnspec, Fnspec
from . import helpers


def codegen(
    module: ModuleType,
    *,
    dst: str,
    dry_run: bool,
    with_main: bool,
    ignore_only: bool = False,
) -> None:
    c = Config(
        module, dst=dst, dry_run=dry_run, with_main=with_main, ignore_only=ignore_only
    )
    emit_functions = setup_emit_functions(c)

    with c.output(dry_run=c.dry_run) as fs:
        for filename, emit in emit_functions:
            with fs.open(filename, "w", opener=c.create_prestring_module) as m:
                where = c.resolve_filepath(filename)

                # TODO: refactor code
                imported: t.Dict[str, str] = {}  # spec.module -> exact module name
                spec_map: t.Dict[str, Fnspec] = {}

                for name, spec in c.spec_map.items():
                    if spec.module == "__main__":
                        continue
                    if spec.module not in imported:
                        exact_module_name = helpers.emit_target_spec_import(
                            spec, where=where, m=m
                        )
                        imported[spec.module] = exact_module_name

                    spec_map[name] = dataclasses.replace(
                        spec, _module=imported[spec.module]
                    )

                emit(m, where=where, spec_map=spec_map)


class Emit(tx.Protocol):
    def __call__(
        self, m: Module, *, where: str, spec_map: t.Dict[str, Fnspec]
    ) -> Module:
        ...


def setup_emit_functions(c: Config) -> t.List[t.Tuple[str, Emit]]:
    from .emit_main import emit_main

    functions = c.scanned.commands
    components = c.scanned.components

    # fmt: off
    files = [
        ("web.py", t.cast(Emit, partial(
            emit_main,
            functions=functions,
            components=components,
            spec_map=c.spec_map,
            with_main=c.with_main))),
    ]
    # fmt: on
    return files


@dataclasses.dataclass
class Config:
    module: ModuleType
    dst: str
    with_main: bool = False
    dry_run: bool = False
    ignore_only: bool = False
    header: str = "# this module is generated by monogusa.web.codegen"

    @reify
    def scanned(self) -> Scanned:
        return scan_module(self.module, ignore_only=self.ignore_only)

    @reify
    def spec_map(self) -> t.Dict[str, Fnspec]:
        d = {x.__name__: fnspec(x) for x in self.scanned.commands}
        d.update({x.__name__: fnspec(x) for x in self.scanned.components})
        return d

    def output(self, *, dry_run: bool) -> output:
        if dry_run:
            return output(self.dst, use_console=True, verbose=True)
        return output(self.dst)

    def resolve_filepath(self, name: str) -> str:
        return str((pathlib.Path(self.dst) / name).parent.absolute())

    def create_prestring_module(self) -> Module:
        return helpers.setup_module(header=self.header)
