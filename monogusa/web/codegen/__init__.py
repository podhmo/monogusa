from __future__ import annotations
import typing as t
import typing_extensions as tx
from types import ModuleType
import pathlib
import dataclasses
from functools import partial

from prestring.output import output
from monogusa.cli.runtime import collect_commands

from ._codeobject import Module
from . import helpers


def codegen(module: ModuleType, *, dst: str, dry_run: bool, with_main: bool) -> None:
    c = Config(module, dst=dst, dry_run=dry_run, with_main=with_main)
    emit_functions = setup_emit_functions(c)

    with c.output(dry_run=c.dry_run) as fs:
        for filename, emit in emit_functions:
            with fs.open(filename, "w", opener=c.create_prestring_module) as m:
                emit(m=m, where=c.resolve_filepath(filename))


class Emit(tx.Protocol):
    def __call__(self, *, m: Module, where: str) -> Module:
        ...


def setup_emit_functions(c: Config) -> t.List[t.Tuple[str, Emit]]:
    from .emit_routes import emit_routes

    functions = c.target_functions

    # fmt: off
    files = [
        ("web.py", t.cast(Emit, partial(emit_routes, functions, with_main=c.with_main))),
    ]
    # fmt: on
    return files


@dataclasses.dataclass
class Config:
    module: ModuleType
    dst: str
    with_main: bool = False
    dry_run: bool = False
    header: str = "# this module is generated by monogusa.web.codegen"

    @property
    def target_functions(self) -> t.List[t.Callable[..., t.Any]]:
        return list(collect_commands(self.module))

    def output(self, *, dry_run: bool) -> output:
        if dry_run:
            return output(self.dst, use_console=True, verbose=True)
        return output(self.dst)

    def resolve_filepath(self, name: str) -> str:
        return str((pathlib.Path(self.dst) / name).parent.absolute())

    def create_prestring_module(self) -> Module:
        return helpers.setup_module(header=self.header)
